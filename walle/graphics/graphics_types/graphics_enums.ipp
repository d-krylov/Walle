#ifndef WALLE_GRAPHICS_ENUMS_IPP
#define WALLE_GRAPHICS_ENUMS_IPP

namespace Walle {

void VK_CHECK(VkResult result, std::source_location = std::source_location::current());

using DebugMessageSeverityMaskBit = DebugUtilsMessageSeverityMaskBit;
using DebugMessageTypeMaskBit = DebugUtilsMessageTypeMaskBit;
using LogicOperation = LogicOp;
using CompareOperation = CompareOp;
using StencilOperation = StencilOp;

enum class Flags {};

using VideoEncodeH265TransformBlockSizeMask = Mask<VideoEncodeH265TransformBlockSizeMaskBit>;
using VideoEncodeH265StdMask = Mask<VideoEncodeH265StdMaskBit>;
using VideoComponentBitDepthMask = Mask<VideoComponentBitDepthMaskBit>;
using VideoChromaSubsamplingMask = Mask<VideoChromaSubsamplingMaskBit>;
using VideoEncodeRateControlMask = Mask<Flags>;
using VideoEncodeCapabilityMask = Mask<VideoEncodeCapabilityMaskBit>;
using VideoEncodeContentMask = Mask<VideoEncodeContentMaskBit>;
using VideoEncodeUsageMask = Mask<VideoEncodeUsageMaskBit>;
using VideoEncodeH264StdMask = Mask<VideoEncodeH264StdMaskBit>;
using VideoDecodeH264PictureLayoutMask = Mask<VideoDecodeH264PictureLayoutMaskBit>;
using VideoDecodeMask = Mask<Flags>;
using VideoCodingControlMask = Mask<VideoCodingControlMaskBit>;
using VideoEndCodingMask = Mask<Flags>;
using VideoSessionParametersCreateMask = Mask<Flags>;
using VideoSessionCreateMask = Mask<VideoSessionCreateMaskBit>;
using VideoCapabilityMask = Mask<VideoCapabilityMaskBit>;
using VideoCodecOperationMask = Mask<VideoCodecOperationMaskBit>;
using PresentGravityMask = Mask<PresentGravityMaskBit>;
using FrameBoundaryMask = Mask<FrameBoundaryMaskBit>;
using OpticalFlowUsageMask = Mask<OpticalFlowUsageMaskBit>;
using OpticalFlowGridSizeMask = Mask<OpticalFlowGridSizeMaskBit>;
using ImageCompressionFixedRateMask = Mask<ImageCompressionFixedRateMaskBit>;
using GraphicsPipelineLibraryMask = Mask<GraphicsPipelineLibraryMaskBit>;
using HostImageCopyMask = Mask<HostImageCopyMaskBit>;
using ImageFormatConstraintsMask = Mask<Flags>;
using SubmitMask = Mask<SubmitMaskBit>;
using OpticalFlowSessionCreateMask = Mask<OpticalFlowSessionCreateMaskBit>;
using PipelineRasterizationStateStreamCreateMask = Mask<Flags>;
using PipelineRasterizationConservativeStateCreateMask = Mask<Flags>;
using DeviceMemoryReportMask = Mask<Flags>;
using DebugUtilsMessengerCreateMask = Mask<Flags>;
using DebugUtilsMessageTypeMask = Mask<DebugUtilsMessageTypeMaskBit>;
using ValidationCacheCreateMask = Mask<Flags>;
using AttachmentDescriptionMask = Mask<AttachmentDescriptionMaskBit>;
using ImageCompressionMask = Mask<ImageCompressionMaskBit>;
using FramebufferCreateMask = Mask<FramebufferCreateMaskBit>;
using InstanceCreateMask = Mask<InstanceCreateMaskBit>;
using PipelineCoverageModulationStateCreateMask = Mask<Flags>;
using PipelineStageMask = Mask<PipelineStageMaskBit>;
using DisplayModeCreateMask = Mask<Flags>;
using ToolPurposeMask = Mask<ToolPurposeMaskBit>;
using ImageAspectMask = Mask<ImageAspectMaskBit>;
using MemoryMapMask = Mask<MemoryMapMaskBit>;
using DescriptorBindingMask = Mask<DescriptorBindingMaskBit>;
using QueryPipelineStatisticMask = Mask<QueryPipelineStatisticMaskBit>;
using MacOSSurfaceCreateMask = Mask<Flags>;
using CommandBufferUsageMask = Mask<CommandBufferUsageMaskBit>;
using QueryResultMask = Mask<QueryResultMaskBit>;
using OpticalFlowExecuteMask = Mask<OpticalFlowExecuteMaskBit>;
using BufferUsageMask = Mask<BufferUsageMaskBit>;
using VideoDecodeUsageMask = Mask<VideoDecodeUsageMaskBit>;
using CullModeMask = Mask<CullModeMaskBit>;
using PipelineCoverageReductionStateCreateMask = Mask<Flags>;
using ImageViewCreateMask = Mask<ImageViewCreateMaskBit>;
using PipelineDepthStencilStateCreateMask = Mask<PipelineDepthStencilStateCreateMaskBit>;
using MemoryHeapMask = Mask<MemoryHeapMaskBit>;
using FenceCreateMask = Mask<FenceCreateMaskBit>;
using PipelineDynamicStateCreateMask = Mask<Flags>;
using StencilFaceMask = Mask<StencilFaceMaskBit>;
using ShaderModuleCreateMask = Mask<Flags>;
using MemoryUnmapMask = Mask<MemoryUnmapMaskBit>;
using PipelineCacheCreateMask = Mask<PipelineCacheCreateMaskBit>;
using AccelerationStructureCreateMask = Mask<AccelerationStructureCreateMaskBit>;
using PipelineViewportSwizzleStateCreateMask = Mask<Flags>;
using QueryControlMask = Mask<QueryControlMaskBit>;
using SubpassDescriptionMask = Mask<SubpassDescriptionMaskBit>;
using DeviceQueueCreateMask = Mask<DeviceQueueCreateMaskBit>;
using PerformanceCounterDescriptionMask = Mask<PerformanceCounterDescriptionMaskBit>;
using PipelineVertexInputStateCreateMask = Mask<Flags>;
using PipelineLayoutCreateMask = Mask<PipelineLayoutCreateMaskBit>;
using SemaphoreCreateMask = Mask<Flags>;
using ShaderCorePropertiesMask = Mask<ShaderCorePropertiesMaskBit>;
using SparseMemoryBindMask = Mask<SparseMemoryBindMaskBit>;
using PipelineColorBlendStateCreateMask = Mask<PipelineColorBlendStateCreateMaskBit>;
using DisplayPlaneAlphaMask = Mask<DisplayPlaneAlphaMaskBit>;
using PipelineTessellationStateCreateMask = Mask<Flags>;
using WaylandSurfaceCreateMask = Mask<Flags>;
using DirectFBSurfaceCreateMask = Mask<Flags>;
using EventCreateMask = Mask<EventCreateMaskBit>;
using QueryPoolCreateMask = Mask<Flags>;
using VideoEncodeH264RateControlMask = Mask<VideoEncodeH264RateControlMaskBit>;
using ExternalMemoryHandleTypeMask = Mask<ExternalMemoryHandleTypeMaskBit>;
using DirectDriverLoadingMask = Mask<Flags>;
using ShaderCreateMask = Mask<ShaderCreateMaskBit>;
using FormatFeatureMask = Mask<FormatFeatureMaskBit>;
using DescriptorSetLayoutCreateMask = Mask<DescriptorSetLayoutCreateMaskBit>;
using DescriptorPoolCreateMask = Mask<DescriptorPoolCreateMaskBit>;
using ConditionalRenderingMask = Mask<ConditionalRenderingMaskBit>;
using AccelerationStructureMotionInfoMask = Mask<Flags>;
using DependencyMask = Mask<DependencyMaskBit>;
using CommandBufferResetMask = Mask<CommandBufferResetMaskBit>;
using RenderPassCreateMask = Mask<RenderPassCreateMaskBit>;
using PipelineMultisampleStateCreateMask = Mask<Flags>;
using VideoEncodeMask = Mask<VideoEncodeMaskBit>;
using StreamDescriptorSurfaceCreateMask = Mask<Flags>;
using SemaphoreImportMask = Mask<SemaphoreImportMaskBit>;
using PipelineCreateMask = Mask<PipelineCreateMaskBit>;
using MemoryPropertyMask = Mask<MemoryPropertyMaskBit>;
using CommandPoolCreateMask = Mask<CommandPoolCreateMaskBit>;
using ShaderStageMask = Mask<ShaderStageMaskBit>;
using VideoEncodeH264CapabilityMask = Mask<VideoEncodeH264CapabilityMaskBit>;
using DescriptorPoolResetMask = Mask<Flags>;
using ResolveModeMask = Mask<ResolveModeMaskBit>;
using ImageCreateMask = Mask<ImageCreateMaskBit>;
using GeometryMask = Mask<GeometryMaskBit>;
using RenderingMask = Mask<RenderingMaskBit>;
using DeviceCreateMask = Mask<Flags>;
using VideoEncodeFeedbackMask = Mask<VideoEncodeFeedbackMaskBit>;
using AccessMask = Mask<AccessMaskBit>;
using ImagePipeSurfaceCreateMask = Mask<Flags>;
using ImageUsageMask = Mask<ImageUsageMaskBit>;
using DescriptorUpdateTemplateCreateMask = Mask<Flags>;
using VideoEncodeH265CtbSizeMask = Mask<VideoEncodeH265CtbSizeMaskBit>;
using PeerMemoryFeatureMask = Mask<PeerMemoryFeatureMaskBit>;
using SparseImageFormatMask = Mask<SparseImageFormatMaskBit>;
using IndirectCommandsLayoutUsageMask = Mask<IndirectCommandsLayoutUsageMaskBit>;
using IndirectStateMask = Mask<IndirectStateMaskBit>;
using ColorComponentMask = Mask<ColorComponentMaskBit>;
using ExternalFenceFeatureMask = Mask<ExternalFenceFeatureMaskBit>;
using CommandPoolTrimMask = Mask<Flags>;
using XcbSurfaceCreateMask = Mask<Flags>;
using GeometryInstanceMask = Mask<GeometryInstanceMaskBit>;
using CommandPoolResetMask = Mask<CommandPoolResetMaskBit>;
using SubgroupFeatureMask = Mask<SubgroupFeatureMaskBit>;
using BuildAccelerationStructureMask = Mask<BuildAccelerationStructureMaskBit>;
using SampleCountMask = Mask<SampleCountMaskBit>;
using PipelineCompilerControlMask = Mask<PipelineCompilerControlMaskBit>;
using PrivateDataSlotCreateMask = Mask<Flags>;
using DeviceAddressBindingMask = Mask<DeviceAddressBindingMaskBit>;
using DebugReportMask = Mask<DebugReportMaskBit>;
using PipelineCreationFeedbackMask = Mask<PipelineCreationFeedbackMaskBit>;
using AcquireProfilingLockMask = Mask<AcquireProfilingLockMaskBit>;
using VideoEncodeRateControlModeMask = Mask<VideoEncodeRateControlModeMaskBit>;
using SemaphoreWaitMask = Mask<SemaphoreWaitMaskBit>;
using FormatFeatureMask2 = Mask<FormatFeatureMaskBit2>;
using SamplerCreateMask = Mask<SamplerCreateMaskBit>;
using DeviceDiagnosticsConfigMask = Mask<DeviceDiagnosticsConfigMaskBit>;
using BufferViewCreateMask = Mask<Flags>;
using RefreshObjectMask = Mask<RefreshObjectMaskBit>;
using PipelineShaderStageCreateMask = Mask<PipelineShaderStageCreateMaskBit>;
using PipelineStageMask2 = Mask<PipelineStageMaskBit2>;
using AccelerationStructureMotionInstanceMask = Mask<Flags>;
using VideoEncodeH265RateControlMask = Mask<VideoEncodeH265RateControlMaskBit>;
using MemoryDecompressionMethodMask = Mask<MemoryDecompressionMethodMaskBit>;
using DebugUtilsMessageSeverityMask = Mask<DebugUtilsMessageSeverityMaskBit>;
using ScreenSurfaceCreateMask = Mask<Flags>;
using PipelineRasterizationDepthClipStateCreateMask = Mask<Flags>;
using BuildMicromapMask = Mask<BuildMicromapMaskBit>;
using MicromapCreateMask = Mask<MicromapCreateMaskBit>;
using PipelineCreateMask2 = Mask<PipelineCreateMaskBit2>;
using PipelineCoverageToColorStateCreateMask = Mask<Flags>;
using BufferUsageMask2 = Mask<BufferUsageMaskBit2>;
using VideoEncodeH265CapabilityMask = Mask<VideoEncodeH265CapabilityMaskBit>;
using CompositeAlphaMask = Mask<CompositeAlphaMaskBit>;
using QueueMask = Mask<QueueMaskBit>;
using PipelineInputAssemblyStateCreateMask = Mask<Flags>;
using SwapchainCreateMask = Mask<SwapchainCreateMaskBit>;
using DisplaySurfaceCreateMask = Mask<Flags>;
using VideoBeginCodingMask = Mask<Flags>;
using PhysicalDeviceSchedulingControlsMask = Mask<PhysicalDeviceSchedulingControlsMaskBit>;
using PipelineViewportStateCreateMask = Mask<Flags>;
using IOSSurfaceCreateMask = Mask<Flags>;
using PipelineRasterizationStateCreateMask = Mask<Flags>;
using AndroidSurfaceCreateMask = Mask<Flags>;
using VideoDecodeCapabilityMask = Mask<VideoDecodeCapabilityMaskBit>;
using FenceImportMask = Mask<FenceImportMaskBit>;
using ViSurfaceCreateMask = Mask<Flags>;
using ExternalFenceHandleTypeMask = Mask<ExternalFenceHandleTypeMaskBit>;
using Win32SurfaceCreateMask = Mask<Flags>;
using XlibSurfaceCreateMask = Mask<Flags>;
using ExternalMemoryHandleTypeMask = Mask<ExternalMemoryHandleTypeMaskBit>;
using MetalSurfaceCreateMask = Mask<Flags>;
using HeadlessSurfaceCreateMask = Mask<Flags>;
using DebugUtilsMessengerCallbackDataMask = Mask<Flags>;
using BufferCreateMask = Mask<BufferCreateMaskBit>;
using MemoryAllocateMask = Mask<MemoryAllocateMaskBit>;
using AccessMask2 = Mask<AccessMaskBit2>;
using DeviceGroupPresentModeMask = Mask<DeviceGroupPresentModeMaskBit>;
using ExternalMemoryFeatureMask = Mask<ExternalMemoryFeatureMaskBit>;
using ExternalMemoryFeatureMask = Mask<ExternalMemoryFeatureMaskBit>;
using PresentScalingMask = Mask<PresentScalingMaskBit>;
using SurfaceTransformMask = Mask<SurfaceTransformMaskBit>;
using ExternalSemaphoreFeatureMask = Mask<ExternalSemaphoreFeatureMaskBit>;
using ExternalSemaphoreHandleTypeMask = Mask<ExternalSemaphoreHandleTypeMaskBit>;
using SurfaceCounterMask = Mask<SurfaceCounterMaskBit>;
using PipelineDiscardRectangleStateCreateMask = Mask<Flags>;

using DebugMessengerCreateMask = DebugUtilsMessengerCreateMask;
using DebugMessageSeverityMask = DebugUtilsMessageSeverityMask;
using DebugMessageTypeMask = DebugUtilsMessageTypeMask;

} // namespace Walle

#endif // WALLE_GRAPHICS_ENUMS_IPP